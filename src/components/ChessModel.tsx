/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: hanoldaa (https://sketchfab.com/hanoldaa)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/low-poly-chess-set-0f440e2b01ca42f8b3fdee8178c51f20
title: Low Poly Chess Set
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { Chess, PieceType } from "chess.js";
import { Euler, Vector3 } from "@react-three/fiber";
import { ChessVec, Position } from "types/chessTypes";

const LIGHT_SQUARE = "#DFD2C2";
const DARK_SQUARE = "#4C4C4C";

type GLTFResult = GLTF & {
  nodes: {
    Pawn: THREE.Mesh;
    Knight: THREE.Mesh;
    Rook: THREE.Mesh;
    Bishop: THREE.Mesh;
    Queen: THREE.Mesh;
    King: THREE.Mesh;
    BoardOutline_1: THREE.Mesh;
    BoardOutline_2: THREE.Mesh;
    BoardOutline_3: THREE.Mesh;
  };
  materials: {
    Pawn: THREE.MeshStandardMaterial;
    PawnDark: THREE.MeshStandardMaterial;
    Knight: THREE.MeshStandardMaterial;
    KnightDark: THREE.MeshStandardMaterial;
    Rook: THREE.MeshStandardMaterial;
    RookDark: THREE.MeshStandardMaterial;
    Bishop: THREE.MeshStandardMaterial;
    BishopDark: THREE.MeshStandardMaterial;
    Queen: THREE.MeshStandardMaterial;
    QueenDark: THREE.MeshStandardMaterial;
    King: THREE.MeshStandardMaterial;
    KingDark: THREE.MeshStandardMaterial;
    BoardOutlineMaterial: THREE.MeshStandardMaterial;
  };
};

const Piece = ({
  type,
  color,
  pos,
}: {
  type: PieceType;
  color: "w" | "b";
  pos: { x: number; y: number };
}) => {
  const { nodes, materials } = useGLTF(
    "/chess-set-models.glb"
  ) as unknown as GLTFResult;
  const rotation: Euler =
    color === "w" ? [Math.PI / 2, 0, 0] : [Math.PI / 2, 0, Math.PI];

  const getGeometryAndMaterialName = (type: PieceType, color: "b" | "w") => {
    let name: "Bishop" | "Pawn" | "Rook" | "Knight" | "King" | "Queen";
    if (type === "b") name = "Bishop";
    else if (type === "p") name = "Pawn";
    else if (type === "r") name = "Rook";
    else if (type === "n") name = "Knight";
    else if (type === "k") name = "King";
    else if (type === "q") name = "Queen";
    else throw new Error(); // TODO: Fix this, it should not be needed...

    const materialName = `${name}${color === "w" ? "" : "Dark"}` as const;

    return { geometryName: name, materialName };
  };

  const { geometryName, materialName } = getGeometryAndMaterialName(
    type,
    color
  );

  const calculate3DPosition = (chessPos: { x: number; y: number }): Vector3 => {
    // ? a8 is x: 0, y: 0
    return [-chessPos.x, 0, 7 - chessPos.y];
  };

  return (
    <group position={calculate3DPosition(pos)} rotation={rotation}>
      <mesh
        geometry={nodes[geometryName].geometry}
        material={materials[materialName]}
      />
    </group>
  );
};

interface ModelProps {
  fen: string;
  selectedSquare: ChessVec | null;
  handleClick: ({
    x,
    y,
    eventType,
  }: {
    x: number;
    y: number;
    eventType: "mouseDown" | "mouseUp";
  }) => void;
}

export default function ChessModel({
  fen,
  selectedSquare,
  handleClick,
}: ModelProps) {
  const { nodes, materials } = useGLTF(
    "/chess-set-models.glb"
  ) as unknown as GLTFResult;

  const gameEngine = useRef(new Chess(fen));
  const [boardPosition, setBoardPosition] = useState<Position>(
    gameEngine.current.board()
  );
  const [hovered, setHovered] = useState<ChessVec | null>(null);

  useEffect(() => {
    setBoardPosition(() => {
      gameEngine.current.load(fen);
      return gameEngine.current.board();
    });
  }, [fen]);

  return (
    <group dispose={null}>
      <group rotation={[Math.PI / 2, 0, 0]}>
        {boardPosition.map((row, y) =>
          row.map((square, x) => {
            if (square === null) return null;
            return (
              <group key={x + y * 8} rotation={[-Math.PI / 2, 0, 0]}>
                <Piece type={square.type} color={square.color} pos={{ x, y }} />
              </group>
            );
          })
        )}
        <group name="board-outline">
          <mesh geometry={nodes.BoardOutline_1.geometry} />
          <mesh geometry={nodes.BoardOutline_3.geometry} />
          <mesh
            geometry={nodes.BoardOutline_2.geometry}
            material={materials.BoardOutlineMaterial}
          />
        </group>
        <group name="board-tiles" rotation={[Math.PI, 0, 0]}>
          {new Array(8).fill(0).map((_, i) => {
            return new Array(8).fill(0).map((_, j) => {
              let color = (i + j) % 2 === 0 ? LIGHT_SQUARE : DARK_SQUARE;
              if (hovered && hovered.x === i && hovered.y === j) {
                color = "gray";
              }
              if (selectedSquare?.x === i && selectedSquare?.y === j) {
                color = "brown";
              }
              return (
                <mesh
                  key={i + j * 8}
                  position={[-i, j - 7, 0]}
                  onPointerOver={() => setHovered({ x: i, y: j })}
                  onPointerDown={() =>
                    handleClick({ x: i, y: j, eventType: "mouseDown" })
                  }
                  onPointerUp={() =>
                    handleClick({ x: i, y: j, eventType: "mouseUp" })
                  }
                >
                  <planeGeometry args={[1, 1]} />
                  <meshStandardMaterial color={color} />
                </mesh>
              );
            });
          })}
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/chess-set-models.glb");
